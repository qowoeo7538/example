[TOC]

## 1 调用流程

当向WebFlux中的Netty服务器发起请求，服务器中的Boss监听线程会接收该请求，并在完成TCP三次握手后，把连接套接字通道注册到worker线程池的某个NioEventLoop中来处理，然后该NioEventLoop中对应的线程就会轮询该套接字上的读写事件并进行处理。

当注册到worker线程池的 NioEventLoop 上的连接套接字有读事件后，会调用 processSelectedKeys 方法进行处理，然后把读取的数据通过与该通道对应的管道 DefaultChannelPipeline 传播到注册的事件处理器进行处理。这里处理器 HttpServerCodec 负责把二进制流解析为HTTP请求报文，然后传递到管道后面的处理器 HttpServerHandler 中，HttpServerHandler 会调用 ServerContextHandler 的 createOperations 方法，通过代码“channel.eventLoop().execute(op::onHandlerStart)；”把 ChannelOperations 的onHandlerStart 方法作为任务提交到与当前通道对应的 NioEventLoop 管理的队列中。

```java
    protected void onHandlerStart() {
        applyHandler();
    }
    
    protected final void applyHandler() {
        try {
            //1. 调用 适配器 ReactorHttpHandlerAdapter 的 apply 方法
            Mono.fromDirect(handler.apply((INBOUND) this, (OUTBOUND) this)).subscribe(this);
        } catch (Throwable t) {
            channel.close();
        }
    }

    public Mono<Void> apply(HttpServerRequest request, HttpServerResponse response) {
        ServerHttpRequest adaptedRequest;
        ServerHttpResponse adaptedResponse;
        try {
            //2. 创建与 reactor 对应的请求、 响应对象
            adaptedRequest = new ReactorServerHttpRequest(request, BUFFER_ FACTORY);
            adaptedResponse = new ReactorServerHttpResponse(response, BUFFER_ FACTORY);
        } catch (URISyntaxException ex) {
            ...
            response.status(HttpResponseStatus.BAD_ REQUEST);
            return Mono.empty();
        }
        ...
        //3. 这里 httpHandler 为 ServerManager
        return this.httpHandler.handle(adaptedRequest, adaptedResponse)
                .doOnError(ex -> logger.warn(" Handling completed with error: " + ex.getMessage()))
                .doOnSuccess(aVoid -> logger.debug(" Handling completed with success"));
    }
```

